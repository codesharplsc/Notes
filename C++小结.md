##关于C++的小知识点总结


###1.1 引用&与指针*
引用是变量的别名，而指针是指向具体的内存地址

1. 引用不需要分配内存空间，而指针需要，sizeof(引用)可能为sizeof(int)或者sizeof(double)取决于引用的变量，而sizeof(指针)在32位机为4字节

2. 引用在不作为函数参数和返回值时声明时必须对其进行初始化，以后在程序中不能变更这种关系，而指针可以在运行时改变其指向

3. 并不是所有数据类型都可以有引用，如void类型引用`void &x = y`(X),引用的引用`int &&x = y`,引用数组`int &&x = y`(X),指向引用的指针`int & *x = y`(X),然而可以引用指针如`int * y; int*&x = y;`

###1.2 指向常量的指针和常指针
+ const  char *p = &x; p指向的内容不能被修改

+ char * const p = &x; p指针本身不能指向其他内容

###1.3 sizeof运算

		int x = 1; 			//sizeof(x) = 4
		double y = 1.0;		//sizeof(y) = 8
		int *p1 = &x;		//sizeof(p1) = 4
		int a[10];			//sizeof(a)  = 4*10 = 40
		int *p2 = a;		//sizeof(p2) = 4
		double *p3 = &y;	//sizeof(p3) = sizeof(&y) = 4
以上为32位环境下，且(p2+1)加4个字节指向下一个int，(p3+1)加8个字节指向下一个double

###1.4 static & const
- 静态成员: 被所有成员实例所共有，在类外被初始化，可通过类名::变量名访问，默认为0
- 静态函数: 只能访问静态成员，可通过类名::函数名访问
- 常数据成员: `const int a;`只能通过初始化列表对其进行初始化,过后不能更改
- 常成员函数: `void Test() const;`不能修改类的数据成员，只能调用常成员函数(防止调用其他函数更改数据成员)

###1.5内联函数inline
通过在函数名前添加`inline`标识符使函数变为内联函数。调用内联函数时编译器对内联函数进行扩展，**用内联函数体的代码替换掉内联函数调用语句**.

**高效**:用内联函数体省去了函数调用保护现场，参数传递的过程。

**安全性**:与宏定义相比内联函数会进行语意检查

内联函数代码简短，**一般不允许有循环分支递归部分，利用空间换时间**。在面向对象程序设计中成员函数自动被解析为内联函数，不需要加`inline`。

###1.6继承
构造函数调用顺序: *基类->对象成员->派生类*

注:在派生类的构造函数中需要显示的调用基类的构造函数(除非调用无参构造函数)
	
	void Child::Child(int a,int b,int c):Base(a)
	{
		.....
	}

析构函数调用顺序: *派生类->对象成员->基类*

***默认为private继承方式,派生类继承基类所有成员函数，但不继承构造函数和析构函数***

 
####1.6.1虚基类
对于多重继承，`B->C1; B->C2; C1,C2->C3;`类C3同时继承C1,C2,在未声明虚基类时，C3包括两个B的副本，分别来自父类C1，C2，当声明B是C1的虚基类，同时B是C2的虚基类时，C3此时只保留B的一份副本，声明时格式
	
	class C1:public virtual B{
	};
	
	class C2:public virtual B{
	};
	class C3 :public C1,public C2{
		void C3(int a,int b, int c):C2(a),C3(b),B(a){
		//base class B's constructor method needs to be called directly
		...
		
		}
	}
*虚基类的构造函数优于普通基类构造函数，并且所有虚基类直接或间接的派生类都必须包含对该虚基类构造函数的直接调用*

利用以上特性设计不能被继承的类时，可以将B虚继承类A，但类A中构造函数私有，同时B是A的友元类，这时任何类C希望继承B必须显示调用A的构造函数，但此时A的构造函数私有，只能A和B类调用，这样C就不能继承B

####1.6.2虚函数
虚函数

	virtual ReturnValue FunctionName(Arguments);
	
当基类的指针和引用指向派生类时只能调用基类的成员和成员函数，这个时候将其声明为虚函数，该指针或引用就能够**在指向基类时调用基类的成员和成员函数，在指向派生类时调用派生类的成员和成员函数**

**此特性尤其适用于将基类的析构函数声明为虚函数，这样在释放动态空间时调用的是对应的派生类或者基类的析构函数**
	
虚函数的函数返回值，名称，参数必须完全一样，无论是否给出声明，派生类中对其进行的重载均为虚函数

纯虚函数:
	
	virtual ReturnValue FunctionName(Arguments) = 0;

包含该函数的类成为**抽象类**，不能生成该类的对象，同时对于该类的派生类都应该对纯虚函数进行具体实现





